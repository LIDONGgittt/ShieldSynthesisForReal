__author__ = 'meng wu'

from datatypes.predicates import Predicate

class AnsicEncoder(object):

    def __init__(self, specDFA):
        self.specDFA = specDFA
        self.shieldModel_ = ""
        self.numOfShieldBits_ = 0
        self.tmpCount_ = 0
        self.designModel_ = []
        self.designModelStr_ = ""
        self.shieldInputVarNames_ = []
        self.shieldOutputVarNames_ = []
        self.assertions = []
        self.count = 0

    """
    Stores DFA in global variables
    """
    def addShieldModel(self, shieldModel, numOfShieldBits, tmpCount):
        self.shieldModel_ = shieldModel
        self.numOfShieldBits_ = numOfShieldBits
        self.tmpCount_= tmpCount

    """
    Stores DFA in global variables
    """
    def addDesignModel(self, designModel):
        self.designModel_= designModel.split('\n')
        self.designModelStr_= designModel

    """
    Creates entire verilog file, consisting of main, shield, design Module
    and returns result as string
    """
    def getEncodedData(self):
        for var in self.specDFA.getInputVars():
            self.shieldInputVarNames_.append(self.specDFA.getVarName(var))
        for var in self.specDFA.getOutputVars():
            self.shieldInputVarNames_.append(self.specDFA.getVarName(var))

        for var in self.specDFA.getOutputVars():
            var_name = self.specDFA.getVarName(var) + "__1"
            self.shieldOutputVarNames_.append(var_name)

        shield_module = self.encodeShieldModel()
        return shield_module



    """
    Builds an Verilog Module from a given shield model
    """
    def encodeShieldModel(self):

        enc = ""
        enc += self.encode_header()
        enc += self.encode_variables(self.shieldInputVarNames_, self.shieldOutputVarNames_)
        enc += self.encode_model(self.numOfShieldBits_, self.tmpCount_)
        enc += self.encode_transit(self.numOfShieldBits_)
        enc += '  return 0; \n}\n'

        enc += self.encode_lp()
        return enc


    '''
    Returns header

    '''
    def encode_header(self):
        header = "//This file is automatically generated by Shield Synthesis tool.\n\n"

        header += "#include<stdio.h>\n"
        header += "#include <stdbool.h>\n"
        header += "#include<z3.h>\n"
        header += "#include<stdlib.h>\n"
        header += "#include<stdarg.h>\n"
        header += "#include<memory.h>\n"
        header += "#include<setjmp.h>\n"
        header += "\n\n"
        return header


    '''
    Returns the declaration of all input and output, temporary, and state variables

    '''
    def encode_variables(self, input_vars, output_vars):

        var_enc = "struct IOVars{\n"

        #declare input and output variables
        for var_name in input_vars:
            var_enc += "  bool " + var_name + ";  //input\n"
        for var_name in output_vars:
            var_enc += "  bool " + var_name + ";  //output\n"
        var_enc += "};\n\n"


        return var_enc

    def encode_model(self, num_of_bits, tmp_count):
        mod = 'int shield( struct IOVars *var){\n'

        # encode temporary variables (wires)
        for statePos in range(0, num_of_bits):
            state_wire = "s" + str(statePos) + "n"
            mod += "  bool " + state_wire + " = 0;\n"

        for i in range(1, tmp_count):
            tmp_wire = "tmp" + str(i)
            mod += "  bool " + tmp_wire + " = 0;\n"

        # encode regs
        for statePos in range(0, num_of_bits):
            state = "s" + str(statePos)
            mod += "  static bool " + state + " = 0;\n"

        mod += self.shieldModel_
        return mod

    def encode_transit(self, num_of_bits):
        mod = '\n  //encode transition state\n'
        for statePos in range(0, num_of_bits):
            mod += "  s" + str(statePos) + " = " "s" + str(statePos) + "n;\n"
        return mod

    def encode_lp(self):
        pl = '\n\n\nvoid lp(struct IOVars *var){\n'

        self.count = 0
        assertions = ''
        lits = set()
        for var in self.specDFA.getOutputVars():
            var_name = self.specDFA.getVarName(var)
            predicates = self.specDFA.getPredicates()
            if var_name in predicates:
                predicate_parser = Predicate()
                predicate_parser.tokenize(predicates[var_name])
                predicate_ast = predicate_parser.parse()
                lits = lits.union(predicate_ast.getLits())
                assertion, count = self.solver_assert(predicate_ast)
                assertions += assertion
        pl += self.solver_init(lits)
        pl += assertions

        pl += self.solver_cc()
        return pl


    def solver_init(self, lits):
        init =  '  Z3_context ctx;\n'
        init += '  Z3_solver s;\n'
        init += '  Z3_model m = 0;\n'
        init += '  Z3_ast args[2];\n'
        for lit in lits:
            init += '  Z3_ast' + lit + ' = mk_real_var(ctx, "' + lit + '");\n'
        init += '  ctx = mk_context();\n'
        init += '  s = mk_solver(ctx);\n'
        return init

    def solver_cc(self): # check & clean solver
        check = '  check(ctx, s);\n'
        check += '  del_solver(ctx, s);\n'
        check += '  Z3_del_context(ctx);\n'
        check += '\n}\n'
        return check



    def solver_assert(self, predicate):
        ast_name = ''

        if predicate.getType()==3:
            lassertion, last = self.solver_assert(predicate.getLeft())
            rassertion, rast = self.solver_assert(predicate.getRight())
            assertion = lassertion + rassertion
            ret = self.op2api(predicate.getValue(), last, rast)
            assertion += ret[0]
            ast_name = 'ast_' + str(self.count)
            assertion += '  Z3_ast ' + ast_name + ' = ' + ret[1]
            self.count += 1

        elif predicate.getType() == 0:# fix: mk_int_var
            assertion = ''
            ast_name = predicate.getValue()
        elif predicate.getType() == 1:
            ast_name = 'ast_' + str(self.count)
            assertion = '  Z3_ast ' + ast_name + ' = mk_int(ctx, ' + predicate.getValue() + ');\n'
            self.count += 1
        elif predicate.getType() == 2:
            ast_name = 'ast_' + str(self.count)
            assertion = '  Z3_ast ' + ast_name + ' = mk_real(ctx, ' + predicate.getValue() + ');\n'
            self.count += 1


        return assertion, ast_name


    def op2api(self, op, left, right):
        ret = ['', '']

        if op == '+':
            ret[0] = '  arg[0] = ' + left + ';\n  arg[1] = ' + right + ';\n'
            ret[1] = 'Z3_mk_add(ctx, 2, args);\n'
        elif op == '-':
            ret[0] = '  arg[0] = ' + left + ';\n  arg[1] = ' + right + ';\n'
            ret[1] = 'Z3_mk_sub(ctx, 2, args);\n'
        elif op == '*':
            ret[0] = '  arg[0] = '+ left + ';\n  arg[1] = ' + right + ';\n'
            ret[1] = 'Z3_mk_mul(ctx, 2, args);\n'
        elif op == '/':
            ret[1] = 'Z3_mk_div(ctx,' + left + ',' + right + ');\n'
        elif op == '&':
            ret[0] = '  arg[0] = ' + left + ';\n  arg[1] = ' + right + ';\n'
            ret[1] = 'Z3_mk_and(ctx, 2, args);\n'
        elif op == '|':
            ret[0] = '  arg[0] = '+ left + ';\n  arg[1] = ' + right + ';\n'
            ret[1] = 'Z3_mk_or(ctx, 2, args);\n'
        elif op == '%':
            ret[1] = 'Z3_mk_rem(ctx,' + left + ',' + right + ');\n'
        elif op == 'mod':
            ret[1] = 'Z3_mk_mod(ctx,'+ left + ',' + right + ');\n'
        elif op == '^':
            ret[1] = 'Z3_mk_pow(ctx,'+ left + ',' + right + ');\n'
        elif op == '>':
            ret[1] = 'Z3_mk_gt(ctx,'+ left + ',' + right + ');\n'
        elif op == '>=':
            ret[1] = 'Z3_mk_ge(ctx,' + left + ',' + right + ');\n'
        elif op == '<':
            ret[1] = 'Z3_mk_lt(ctx,' + left + ',' + right + ');\n'
        elif op == '<=':
            ret[1] = 'Z3_mk_le(ctx,' + left + ',' + right + ');\n'
        else:
            raise SyntaxError('Invalid operator in predicates!')
        return ret




