__author__ = 'meng wu'

import re

class AnsicEncoder(object):

    def __init__(self, specDFA):
        self.specDFA = specDFA
        self.shieldModel_= ""
        self.numOfShieldBits_ = 0
        self.tmpCount_ = 0
        self.designModel_ = []
        self.designModelStr_ = ""
        self.shieldInputVarNames_ = []
        self.shieldOutputVarNames_ = []


    """
    Stores DFA in global variables
    """
    def addShieldModel(self, shieldModel, numOfShieldBits, tmpCount):
        self.shieldModel_ = shieldModel
        self.numOfShieldBits_ = numOfShieldBits
        self.tmpCount_= tmpCount

    """
    Stores DFA in global variables
    """
    def addDesignModel(self, designModel):
        self.designModel_= designModel.split('\n')
        self.designModelStr_= designModel

    """
    Creates entire verilog file, consisting of main, shield, design Module
    and returns result as string
    """
    def getEncodedData(self):

        for var in self.specDFA.getInputVars():
            self.shieldInputVarNames_.append(self.specDFA.getVarName(var))
        for var in self.specDFA.getOutputVars():
            self.shieldInputVarNames_.append(self.specDFA.getVarName(var))

        for var in self.specDFA.getOutputVars():
            var_name = self.specDFA.getVarName(var) + "__1"
            self.shieldOutputVarNames_.append(var_name)

        shield_module = self.encodeShieldModel()
        return shield_module



    """
    Builds an Verilog Module from a given shield model
    """
    def encodeShieldModel(self):

        enc = ""

        enc += self.encode_header()
        enc += self.encode_variables(self.shieldInputVarNames_, self.shieldOutputVarNames_, self.numOfShieldBits_, self.tmpCount_)
        enc += self.encode_model()
        return enc



    """
    Encodes the Main Module of the Verilog File that connects Design and Shield to one module
    """
    def createMainModule(self):

        #design module could define more modules. parse variables only from design module.
        module_str = ""
        for line in self.designModel_[1:]:
            line = line.strip()
            line = re.sub(' +',' ',line)
            if line.startswith("endmodule"):
                break
            module_str += line + '\n'
        design_input_vars = self.parseVariables(module_str, True)
        design_output_vars = self.parseVariables(module_str, False)

        enc = ""
        enc += self.encode_header("main", design_input_vars+design_output_vars)


        #encode_variables

        #declare inputs and outputs
        for var in design_input_vars:
            enc += "  input " + var + ";\n"
        for var in design_output_vars:
            enc += "  output " + var + ";\n"
        enc += "\n"

        #declare wires (design outputs that are also shield inputs)
        shield_inputs_from_design = []
        for shield_in_var in self.shieldInputVarNames_:
            if shield_in_var in design_output_vars:
                enc += "  wire " + shield_in_var + "_design;\n"
                shield_inputs_from_design.append(shield_in_var)
        enc += "\n"

        #define design (outputs of design that are also inputs for shield are renamed)
        design_var_list = []
        for in_var in design_input_vars:
            design_var_list.append(in_var)
        for out_var in design_output_vars:
            if out_var in shield_inputs_from_design:
                design_var_list.append(out_var+"_design")
            else:
                design_var_list.append(out_var)

        design_vars = ""
        for var in design_var_list:
            design_vars += var + ", "
        design_vars=design_vars[0:len(design_vars)-2]

        enc += "  design m_design(" + design_vars + ");\n"

        #define shield
        if "clock" in design_var_list:
            shield_vars = "clock, "
        else:
            shield_vars = "clk, "
        for var in self.shieldInputVarNames_:
            if var in shield_inputs_from_design:
                shield_vars += var + "_design, "
            else:
                shield_vars += var + ", "
        #shiled output variables without terminating "1"
        for var in shield_inputs_from_design:
            shield_vars += var + ", "
        shield_vars=shield_vars[0:len(shield_vars)-2]

        enc += "  shield m_shield(" + shield_vars  + ");\n\n"

        enc += "endmodule\n\n"""

        return enc


    '''
    Returns header

    '''
    def encode_header(self):
        header = "This file is automatically generated by Shield Synthesis tool.\n"

        header += "#include <stdbool.h>\n#include<z3.h>\n\n"

        return header


    '''
    Returns the declaration of all input and output, temporary, and state variables

    '''
    def encode_variables(self, input_vars, output_vars, num_of_bits, tmp_count):

        var_enc = "struct IOVars{\n"

        #declare input and output variables
        for var_name in input_vars:
            var_enc += "  bool " + var_name + ";\n"
        for var_name in output_vars:
            var_enc += "  bool " + var_name + ";\n"
        var_enc += "};\n"

        return var_enc

    def encode_model(self):
        mod = 'int func( struct IOVars var){\n'

        mod += self.shieldModel_

        mod += 'return 0; \n}\n'
        return mod